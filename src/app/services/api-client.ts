//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IServiceProxy {
    /**
     * @param body (optional)
     * @return OK
     */
    register(body?: UserRegistrationInputDto | undefined): Observable<AuthResponse>;
    /**
     * @param body (optional)
     * @return OK
     */
    login(body?: UserLoginInputDto | undefined): Observable<AuthResponse>;
    /**
     * @param body (optional)
     * @return OK
     */
    sendMessage(body?: ChatMessageInputDto | undefined): Observable<void>;
    /**
     * @return OK
     */
    history(sessionId: string): Observable<ChatMessage[]>;
    /**
     * @return OK
     */
    userChatHistory(): Observable<ChatMessageHistoryDto[]>;
    /**
     * @return OK
     */
    session(sessionId: string): Observable<void>;
    /**
     * @param file (optional)
     * @param title (optional)
     * @param documentType (optional)
     * @return OK
     */
    upload(file?: FileParameter | undefined, title?: string | undefined, documentType?: string | undefined): Observable<LegalDocument>;
    /**
     * @param body (optional)
     * @return OK
     */
    analyze(body?: DocumentAnalysisInputDto | undefined): Observable<DocumentAnalysisOutputDto>;
    /**
     * @return OK
     */
    list(): Observable<LegalDocument[]>;
    /**
     * @return OK
     */
    documentGET(id: number): Observable<LegalDocument>;
    /**
     * @return OK
     */
    documentDELETE(id: number): Observable<void>;
    /**
     * @return OK
     */
    health(): Observable<void>;
    /**
     * @return OK
     */
    detailed(): Observable<void>;
    /**
     * @param page (optional)
     * @param pageSize (optional)
     * @param search (optional)
     * @param region (optional)
     * @param isActive (optional)
     * @return OK
     */
    usersAll(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, region?: string | undefined, isActive?: boolean | undefined): Observable<UserDto[]>;
    /**
     * @return OK
     */
    usersGET(id: number): Observable<UserDetailDto>;
    /**
     * @return OK
     */
    usersDELETE(id: number): Observable<void>;
    /**
     * @param body (optional)
     * @return OK
     */
    status(id: number, body?: UpdateUserStatusRequest | undefined): Observable<void>;
    /**
     * @return OK
     */
    stats(): Observable<UserStats>;
}

@Injectable()
export class ServiceProxy implements IServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return OK
     */
    register(body?: UserRegistrationInputDto | undefined, httpContext?: HttpContext): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    login(body?: UserLoginInputDto | undefined, httpContext?: HttpContext): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    sendMessage(body?: ChatMessageInputDto | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Chat/send-message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    history(sessionId: string, httpContext?: HttpContext): Observable<ChatMessage[]> {
        let url_ = this.baseUrl + "/api/Chat/history/{sessionId}";
        if (sessionId === undefined || sessionId === null)
            throw new globalThis.Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessage[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessage[]>;
        }));
    }

    protected processHistory(response: HttpResponseBase): Observable<ChatMessage[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatMessage.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    userChatHistory(httpContext?: HttpContext): Observable<ChatMessageHistoryDto[]> {
        let url_ = this.baseUrl + "/api/Chat/userChatHistory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserChatHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserChatHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessageHistoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessageHistoryDto[]>;
        }));
    }

    protected processUserChatHistory(response: HttpResponseBase): Observable<ChatMessageHistoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatMessageHistoryDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    session(sessionId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Chat/session/{sessionId}";
        if (sessionId === undefined || sessionId === null)
            throw new globalThis.Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional)
     * @param title (optional)
     * @param documentType (optional)
     * @return OK
     */
    upload(file?: FileParameter | undefined, title?: string | undefined, documentType?: string | undefined, httpContext?: HttpContext): Observable<LegalDocument> {
        let url_ = this.baseUrl + "/api/Document/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (title === null || title === undefined)
            throw new globalThis.Error("The parameter 'title' cannot be null.");
        else
            content_.append("Title", title.toString());
        if (documentType === null || documentType === undefined)
            throw new globalThis.Error("The parameter 'documentType' cannot be null.");
        else
            content_.append("DocumentType", documentType.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalDocument>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalDocument>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<LegalDocument> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LegalDocument.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    analyze(body?: DocumentAnalysisInputDto | undefined, httpContext?: HttpContext): Observable<DocumentAnalysisOutputDto> {
        let url_ = this.baseUrl + "/api/Document/analyze";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnalyze(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnalyze(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentAnalysisOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentAnalysisOutputDto>;
        }));
    }

    protected processAnalyze(response: HttpResponseBase): Observable<DocumentAnalysisOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentAnalysisOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    list(httpContext?: HttpContext): Observable<LegalDocument[]> {
        let url_ = this.baseUrl + "/api/Document/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalDocument[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalDocument[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<LegalDocument[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LegalDocument.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    documentGET(id: number, httpContext?: HttpContext): Observable<LegalDocument> {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalDocument>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalDocument>;
        }));
    }

    protected processDocumentGET(response: HttpResponseBase): Observable<LegalDocument> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LegalDocument.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    documentDELETE(id: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDocumentDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    health(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHealth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHealth(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    detailed(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Health/detailed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional)
     * @param pageSize (optional)
     * @param search (optional)
     * @param region (optional)
     * @param isActive (optional)
     * @return OK
     */
    usersAll(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, region?: string | undefined, isActive?: boolean | undefined, httpContext?: HttpContext): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/Users?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (region === null)
            throw new globalThis.Error("The parameter 'region' cannot be null.");
        else if (region !== undefined)
            url_ += "region=" + encodeURIComponent("" + region) + "&";
        if (isActive === null)
            throw new globalThis.Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processUsersAll(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersGET(id: number, httpContext?: HttpContext): Observable<UserDetailDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetailDto>;
        }));
    }

    protected processUsersGET(response: HttpResponseBase): Observable<UserDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersDELETE(id: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUsersDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    status(id: number, body?: UpdateUserStatusRequest | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/{id}/status";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    stats(httpContext?: HttpContext): Observable<UserStats> {
        let url_ = this.baseUrl + "/api/Users/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserStats>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserStats>;
        }));
    }

    protected processStats(response: HttpResponseBase): Observable<UserStats> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserStats.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthResponse {
    token?: string | undefined;
    expiresAt?: Date;
    user?: UserDto;

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export class ChatMessage {
    id?: number;
    sessionId?: string | undefined;
    userId?: number | undefined;
    message?: string | undefined;
    response?: string | undefined;
    createdAt?: Date;
    isFromUser?: boolean;
    documentContext?: string | undefined;
    user?: User;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sessionId = _data["sessionId"];
            this.userId = _data["userId"];
            this.message = _data["message"];
            this.response = _data["response"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.isFromUser = _data["isFromUser"];
            this.documentContext = _data["documentContext"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sessionId"] = this.sessionId;
        data["userId"] = this.userId;
        data["message"] = this.message;
        data["response"] = this.response;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["isFromUser"] = this.isFromUser;
        data["documentContext"] = this.documentContext;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export class ChatMessageHistoryDto {
    sessionId?: string | undefined;
    lastActivity?: Date;
    messageCount?: number;
    lastMessage?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.lastActivity = _data["lastActivity"] ? new Date(_data["lastActivity"].toString()) : undefined as any;
            this.messageCount = _data["messageCount"];
            this.lastMessage = _data["lastMessage"];
        }
    }

    static fromJS(data: any): ChatMessageHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["lastActivity"] = this.lastActivity ? this.lastActivity.toISOString() : undefined as any;
        data["messageCount"] = this.messageCount;
        data["lastMessage"] = this.lastMessage;
        return data;
    }
}

export class ChatMessageInputDto {
    sessionId?: string | undefined;
    message?: string | undefined;
    documentContext?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.message = _data["message"];
            this.documentContext = _data["documentContext"];
        }
    }

    static fromJS(data: any): ChatMessageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["message"] = this.message;
        data["documentContext"] = this.documentContext;
        return data;
    }
}

export class DocumentAnalysisInputDto {
    documentId!: number;
    query!: string;

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): DocumentAnalysisInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentAnalysisInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["query"] = this.query;
        return data;
    }
}

export class DocumentAnalysisOutputDto {
    analysis?: string | undefined;
    relevantSections?: string[] | undefined;
    legalAdvice?: string | undefined;
    success?: boolean;
    error?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.analysis = _data["analysis"];
            if (Array.isArray(_data["relevantSections"])) {
                this.relevantSections = [] as any;
                for (let item of _data["relevantSections"])
                    this.relevantSections!.push(item);
            }
            this.legalAdvice = _data["legalAdvice"];
            this.success = _data["success"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): DocumentAnalysisOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentAnalysisOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["analysis"] = this.analysis;
        if (Array.isArray(this.relevantSections)) {
            data["relevantSections"] = [];
            for (let item of this.relevantSections)
                data["relevantSections"].push(item);
        }
        data["legalAdvice"] = this.legalAdvice;
        data["success"] = this.success;
        data["error"] = this.error;
        return data;
    }
}

export class DocumentSection {
    id?: number;
    documentId?: number;
    title?: string | undefined;
    content?: string | undefined;
    sectionNumber?: number;
    summary?: string | undefined;
    document?: LegalDocument;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentId = _data["documentId"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.sectionNumber = _data["sectionNumber"];
            this.summary = _data["summary"];
            this.document = _data["document"] ? LegalDocument.fromJS(_data["document"]) : undefined as any;
        }
    }

    static fromJS(data: any): DocumentSection {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["title"] = this.title;
        data["content"] = this.content;
        data["sectionNumber"] = this.sectionNumber;
        data["summary"] = this.summary;
        data["document"] = this.document ? this.document.toJSON() : undefined as any;
        return data;
    }
}

export class LegalDocument {
    id?: number;
    title?: string | undefined;
    content?: string | undefined;
    documentType?: string | undefined;
    fileName?: string | undefined;
    uploadedAt?: Date;
    uploadedBy?: User;
    uploadedById?: number | undefined;
    isProcessed?: boolean;
    processingStatus?: string | undefined;
    sections?: DocumentSection[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.documentType = _data["documentType"];
            this.fileName = _data["fileName"];
            this.uploadedAt = _data["uploadedAt"] ? new Date(_data["uploadedAt"].toString()) : undefined as any;
            this.uploadedBy = _data["uploadedBy"] ? User.fromJS(_data["uploadedBy"]) : undefined as any;
            this.uploadedById = _data["uploadedById"];
            this.isProcessed = _data["isProcessed"];
            this.processingStatus = _data["processingStatus"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(DocumentSection.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LegalDocument {
        data = typeof data === 'object' ? data : {};
        let result = new LegalDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["documentType"] = this.documentType;
        data["fileName"] = this.fileName;
        data["uploadedAt"] = this.uploadedAt ? this.uploadedAt.toISOString() : undefined as any;
        data["uploadedBy"] = this.uploadedBy ? this.uploadedBy.toJSON() : undefined as any;
        data["uploadedById"] = this.uploadedById;
        data["isProcessed"] = this.isProcessed;
        data["processingStatus"] = this.processingStatus;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export class UpdateUserStatusRequest {
    isActive?: boolean;

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        return data;
    }
}

export class User {
    id?: number;
    email?: string | undefined;
    passwordHash?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    region?: string | undefined;
    createdAt?: Date;
    lastLoginAt?: Date | undefined;
    isActive?: boolean;
    chatMessages?: ChatMessage[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.passwordHash = _data["passwordHash"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.region = _data["region"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.lastLoginAt = _data["lastLoginAt"] ? new Date(_data["lastLoginAt"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["chatMessages"])) {
                this.chatMessages = [] as any;
                for (let item of _data["chatMessages"])
                    this.chatMessages!.push(ChatMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["passwordHash"] = this.passwordHash;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["region"] = this.region;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["lastLoginAt"] = this.lastLoginAt ? this.lastLoginAt.toISOString() : undefined as any;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.chatMessages)) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export class UserDetailDto {
    id?: number;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    region?: string | undefined;
    phoneNumber?: string | undefined;
    createdAt?: Date;
    lastLoginAt?: Date | undefined;
    isActive?: boolean;
    totalMessages?: number;
    lastMessageAt?: Date | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.region = _data["region"];
            this.phoneNumber = _data["phoneNumber"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.lastLoginAt = _data["lastLoginAt"] ? new Date(_data["lastLoginAt"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            this.totalMessages = _data["totalMessages"];
            this.lastMessageAt = _data["lastMessageAt"] ? new Date(_data["lastMessageAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UserDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["region"] = this.region;
        data["phoneNumber"] = this.phoneNumber;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["lastLoginAt"] = this.lastLoginAt ? this.lastLoginAt.toISOString() : undefined as any;
        data["isActive"] = this.isActive;
        data["totalMessages"] = this.totalMessages;
        data["lastMessageAt"] = this.lastMessageAt ? this.lastMessageAt.toISOString() : undefined as any;
        return data;
    }
}

export class UserDto {
    id?: number;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    region?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["region"] = this.region;
        return data;
    }
}

export class UserGrowthData {
    date?: Date;
    newUsers?: number;

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): UserGrowthData {
        data = typeof data === 'object' ? data : {};
        let result = new UserGrowthData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : undefined as any;
        data["newUsers"] = this.newUsers;
        return data;
    }
}

export class UserLoginInputDto {
    email!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export class UserRegistrationInputDto {
    email!: string;
    password!: string;
    firstName!: string;
    lastName!: string;
    phoneNumber?: string | undefined;
    region!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): UserRegistrationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegistrationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["region"] = this.region;
        return data;
    }
}

export class UserStats {
    totalUsers?: number;
    activeUsers?: number;
    inactiveUsers?: number;
    newUsersThisMonth?: number;
    activeUsersThisWeek?: number;
    regionDistribution?: { [key: string]: number; } | undefined;
    userGrowth?: UserGrowthData[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.totalUsers = _data["totalUsers"];
            this.activeUsers = _data["activeUsers"];
            this.inactiveUsers = _data["inactiveUsers"];
            this.newUsersThisMonth = _data["newUsersThisMonth"];
            this.activeUsersThisWeek = _data["activeUsersThisWeek"];
            if (_data["regionDistribution"]) {
                this.regionDistribution = {} as any;
                for (let key in _data["regionDistribution"]) {
                    if (_data["regionDistribution"].hasOwnProperty(key))
                        (this.regionDistribution as any)![key] = _data["regionDistribution"][key];
                }
            }
            if (Array.isArray(_data["userGrowth"])) {
                this.userGrowth = [] as any;
                for (let item of _data["userGrowth"])
                    this.userGrowth!.push(UserGrowthData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserStats {
        data = typeof data === 'object' ? data : {};
        let result = new UserStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalUsers"] = this.totalUsers;
        data["activeUsers"] = this.activeUsers;
        data["inactiveUsers"] = this.inactiveUsers;
        data["newUsersThisMonth"] = this.newUsersThisMonth;
        data["activeUsersThisWeek"] = this.activeUsersThisWeek;
        if (this.regionDistribution) {
            data["regionDistribution"] = {};
            for (let key in this.regionDistribution) {
                if (this.regionDistribution.hasOwnProperty(key))
                    (data["regionDistribution"] as any)[key] = (this.regionDistribution as any)[key];
            }
        }
        if (Array.isArray(this.userGrowth)) {
            data["userGrowth"] = [];
            for (let item of this.userGrowth)
                data["userGrowth"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

